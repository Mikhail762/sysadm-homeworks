# Домашнее задание к занятию "3.7. Компьютерные сети, лекция 2"

**1. На лекции мы обсудили, что манипулировать размером окна необходимо для эффективного наполнения приемного буфера участников TCP сессии (Flow Control). Подобная проблема в полной мере возникает в сетях с высоким RTT. Например, если вы захотите передать 500 Гб бэкап из региона Юга-Восточной Азии на Восточное побережье США. [Здесь](https://www.cloudping.co/grid) вы можете увидеть и 200 и 400 мс вполне реального RTT. Подсчитайте, какого размера нужно окно TCP чтобы наполнить 1 Гбит/с канал при 300 мс RTT (берем простую ситуацию без потери пакетов). Можно воспользоваться готовым [калькулятором](https://www.switch.ch/network/tools/tcp_throughput/). Ознакомиться с [формулами](https://en.wikipedia.org/wiki/TCP_tuning), по которым работает калькулятор можно, например, на Wiki.**  

В отсутствии потерь пропускная способность равна: T = W/RTT, откуда размер окна W равен: W = 1Гбит/с * 300мс = 1 000 000 000 * 0,3 = 300 000 000 бит. Переведем в байты: 300 000 000 /8 = 37 500 000 байт = 37,5 Мб.  
  
**2. Во сколько раз упадет пропускная способность канала, если будет 1% потерь пакетов при передаче?**

 Я попробовал измерить практически, с помощью программы iperf, запущенной на 2 виртуальных машинах.
Сначала контрольное измерение, без потерь:
```
vagrant@vagrant:~$ iperf3 -c 192.168.10.86 -t 30
[ ID] Interval           Transfer     Bitrate         Retr
...
[  5]   0.00-30.00  sec   335 MBytes  93.6 Mbits/sec    0  
```
Traffic Control, программа управления сетевым трафиком. Эмулирую потерю 1% пакетов на eth0:  
```
vagrant@vagrant:~$ sudo tc qdisc add dev eth0 root netem loss 1%
vagrant@vagrant:~$ iperf3 -c 192.168.10.86 -t 30
...
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-30.00  sec   295 MBytes  82.5 Mbits/sec  2349 
```
Получается снижение bitrate  в 93.6/82.5 = 1.13 раз.  


**3. Какая  максимальная реальная скорость передачи данных достижима при линке 100 Мбит/с? Вопрос про TCP payload, то есть цифры, которые вы реально увидите в операционной системе в тестах или в браузере при скачивании файлов. Повлияет ли размер фрейма на это?**

В отсутствии потерь пакетов и минимизации сервисной информации TCP скорость скачивания будет чуть меньше пропускной способности, коэффициент: (MTU - заголовки TCP и IP) к (MTU + заголовки Ethernet + межкадровый интервал(IFG)).  
Max TCP Payload= (MTU–TCP–IP) / (MTU+Ethernet+IFG) = (1500–40) / (1500+26+12) = 94.9 %  
100 000 000 * 0.949 = 94 900 000 бит/с = 11 862 500 байт/с = 11,86 Мбайт/сек  
Это справедливо для стандартных Ethernet устройств. Возможно использование фреймов большего размера (Giants, Jumbo), однако это требует поддержки всех устройств на линии, поэтому имеет смысл использовать только между парой устройств на специальных высокоскоростных линиях связи.


**4. Что на самом деле происходит, когда вы открываете сайт? :)
На прошлой лекции был приведен сокращенный вариант ответа на этот вопрос. Теперь вы знаете намного больше, в частности про IP адресацию, DNS и т.д.
Опишите максимально подробно насколько вы это можете сделать, что происходит, когда вы делаете запрос `curl -I http://netology.ru` с вашей рабочей станции. Предположим, что arp кеш очищен, в локальном DNS нет закешированных записей.**

Для соединения с сервером сначала программа должна узнать IP-адрес сервера netology.ru. Методы могут различаться в разных ОС и программах, но типичный алгоритм такой:  
Curl вызывает в отдельном треде функцию gethostbyname стандартной библиотеки glibc, которая в определенном порядке (указанном в /etc/nsswitch.conf) проверяет файл /etc/hosts и обращается к сервису DNS. DNS при определении адреса использует name server, указанный в конфиге /etc/resolv.conf.  
Если DNS-сервер знает ответ, то он сразу же возвращает его клиенту (это может произойти, когда запрошенное имя входит в тот же поддомен, что и имя клиента, или когда сервер уже узнавал данное соответствие для другого клиента и сохранил его в своем кэше).  
Если нет - посылает запрос корневому серверу, который возвращает адрес DNS-сервера, ответственного за зону .ru. Обратившись к нему, наш DNS-сервер получит адрес сервера, ответственного за домен netology.ru и, узнав у этого сервера адрес искомого веб-сервера, отправляет его клиенту.

Отправка пакетов по известному IP-адресу происходит так:  
Используя таблицу маршрутизации, определяем сетевой интерфейс и next hop - следующий узел маршрута. Если адресат в нашей локальной сети - можно сразу отправлять ему, если нет - тогда на маршрутизатор, указанный в таблице. При этом у пакета в заголовке будут адрес источника = адрес интерфейса, который отправляет пакет, адрес назначения = IP-адрес netology.ru.  
Если наш хост находится в сети c частной адресацией, то маршрутизатор, отправляющий наш пакет в Интернет, в соответствии со своими правилами, должен подменить адрес источника и порт на свой публичный ip-адрес и свободный порт, и записать замену в свою NAT-таблицу; а при приеме ответа сервера - подменить адрес и порт назначения со своего на адрес и порт клиента.
Далее, маршрутизаторы в соответствии со своими таблицами маршрутизации, по цепочке передают пакеты до сервера, и обратно.

Коммутация.  
Когда сетевой интерфейс должен отправить пакет, ему нужно знать MAC-адрес, которому нужно отправить кадр. Если в ARP-кэше его нет, клиент отправляет широковещательный ARP-запрос, в котором указывает свой MAC и нужный ему IP. Если клиент подключен к коммутатору, тот отправит этот запрос на все порты, кроме исходного.  
Искомый хост, получив такой запрос, пошлет ARP-ответ на MAC-источник запроса, в котором сообщит свой MAC-адрес.   

Таким образом, у Curl будет все необходимое для установки соединения с сервером netology.ru. Программа вызывает сокет и запрашивает поток TCP.  
Клиент выбирает номер начальной последовательности (ISN) и отправляет пакет серверу с установленным битом SYN для открытия соединения.  
Сервер получает пакет с битом SYN и, если готов к установлению соединения, то:  
- Выбирает собственный номер начальной последовательности;
- Устанавливает SYN-бит, чтобы сообщить о выборе начальной последовательности;
- Копирует ISN клиента +1 в поле ACK и добавляет ACK-флаг для обозначения подтверждения получения первого пакета.  
Клиент подтверждает соединение путём отправки пакета:
- Увеличивает номер своей начальной последовательности;
- Увеличивает номер подтверждения получения;
- Устанавливает поле ACK.
Данные передаются следующим образом:
- Когда одна сторона отправляет N байтов, то увеличивает значение поля SEQ на это число.
- Когда вторая сторона подтверждает получение этого пакета (или цепочки пакетов), она отправляет пакет ACK, в котором значение поля ACK равняется последней полученной последовательности.
Закрытие соединения:
- Сторона, которая хочет закрыть соединение, отправляет пакет FIN;
- Другая сторона подтверждает FIN (с помощью ACK) и отправляет собственный FIN-пакет;
- Инициатор прекращения соединения подтверждает получение FIN отправкой собственного ACK.

Далее Curl отправляет запрос:
```
HTTP: HEAD / HTTP/1.1  
Host: netology.ru
User-Agent: curl/7.58.0
Accept: */*
```
И выводит ответ в stdout:  
```
HTTP/1.1 301 Moved Permanently
Date: Fri, 15 Oct 2021 12:13:57 GMT
Connection: keep-alive
Cache-Control: max-age=3600
Expires: Fri, 15 Oct 2021 13:13:57 GMT
Location: https://netology.ru/
```
**5. Сколько и каких итеративных запросов будет сделано при резолве домена `www.google.co.uk`?**
```
dig +trace @8.8.8.8 www.google.co.uk  
.                       49130   IN      NS      m.root-servers.net.
uk.                     172800  IN      NS      dns4.nic.uk.
google.co.uk.           172800  IN      NS      ns1.google.com.
www.google.co.uk.       300     IN      A       64.233.162.94
```
1) для определения корневых серверов;  
2) к корневому серверу для поиска серверов, отвечающих за домен .uk;  
3) name-сервер зоны uk выдал адрес name-сервера ns1.google.com;
4) последний сервер выдал A-запись с IP-адресом www.google.co.uk.  


**6. Сколько доступно для назначения хостам адресов в подсети `/25`? А в подсети с маской `255.248.0.0`. Постарайтесь потренироваться в ручных вычислениях чтобы немного набить руку, не пользоваться калькулятором сразу.**

В IPv4 адресе всего 32 бит - 25 бит маска = 7 бит на адреса. 2^7 = 128 адресов, минус 2 на адрес сети и бродкаст = 126 адресов.  
Во втором октете получается 256 - 248 = 8 = 2^3 -> 3 свободных бита под адрес; плюс по 8 бит в 3 и 4 октетах -> всего 19 бит. 2^19 = 524288; 524288 - 2 = 524286 адресов.  


**7. В какой подсети больше адресов, в `/23` или `/24`?**

В `/23`. Чем короче маска, тем больше бит для адресов.

**8. Получится ли разделить диапазон `10.0.0.0/8` на 128 подсетей по 131070 адресов в каждой? Какая маска будет у таких подсетей?**

В сети `10.0.0.0/8` доступно 24 бит для адресации. 128 = 2^7, 131070 = 2^17 - 2, 7 + 17 = 24, то есть, как раз хватает:  
первая подсеть - 10.0.0.0/15, адреса от 10.0.0.1 до 10.1.255.254  
вторая подсеть - 10.2.0.0/15, адреса от 10.2.0.1 до 10.3.255.254  
последняя подсеть - 10.254.0.0/15, адреса от 10.254.0.1 до 10.255.255.254

 
 ---

### Как оформить ДЗ?

Домашнее задание выполните в файле readme.md в github репозитории. В личном кабинете отправьте на проверку ссылку на .md-файл в вашем репозитории.

Также вы можете выполнить задание в [Google Docs](https://docs.google.com/document/u/0/?tgif=d) и отправить в личном кабинете на проверку ссылку на ваш документ.
Название файла Google Docs должно содержать номер лекции и фамилию студента. Пример названия: "1.1. Введение в DevOps — Сусанна Алиева"
Перед тем как выслать ссылку, убедитесь, что ее содержимое не является приватным (открыто на комментирование всем, у кого есть ссылка). 
Если необходимо прикрепить дополнительные ссылки, просто добавьте их в свой Google Docs.

Любые вопросы по решению задач задавайте в чате Slack.

---
