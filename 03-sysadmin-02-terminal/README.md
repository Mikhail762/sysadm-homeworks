# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"  
  
1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа  
   ***  
   
   `cd is a shell builtin`  
   cd меняет дескриптор /proc/[bash PID]/cwd  
   если бы cd была отдельной программой, менялся бы cwd ее процесса, а не bash  
   Bash бы не мог запускать другие программы    
   
  
2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.    
    ***  
   
   `grep -c <string> <file>`  
   `wc -l < <(grep <string> <file>)`  
     

3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?  
   ***  
   
   Systemd  
       

4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?  
   ***  
   
   `ls <args> 2>/dev/pts/1`  
     

5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.  
   ***  
   
   `sort <file_in >file_out`  
       

6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY?   
   ***  
   
   `<command> > /dev/pts/1`  
   Сможете ли вы наблюдать выводимые данные?  
   `<command> | tee /dev/pts/1`  
   
     
7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?  
   ***  
   
   `bash 5>&1` создает новый процесс bash, создает дескриптор 5 и связывает его с STDOUT текущего процесса bash.  
   `echo` выведет сообщение `netology`, так как связано с тем же pts  
         

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
   ***  
   
        
       ls ~/test /root 3>&1 1>&2 2>&3 | wc -l  
       /home/vagrant/test: control sorted stest test  
       1  
  Команда ls вывела содержимое каталога, а сообщение об ошибке `ls: cannot open directory '/root': Permission denied` попало в pipe  
     
   
9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?  
   ***  
   
   Выводит переменные среды текущего процесса bash. Эти данные также можно получить командами env, printenv, set.  
     

10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.  
    ***  

      *cmdline*  
      Файл только для чтения, только текущим пользователем, содержит командную строку, вызвавшую данный процесс.  
      Аргументы команды отделены и оканчиваются пустым символом '\0'. Если процесс является зомби, файл пустой.  
      *exe*  
      Начиная с ядра linux 2.2, представляет собой символьную ссылку на выполняемый файл, запуск которого инициализировал данный процесс.   
    

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.  
    ***  
    sse4_2  
  

12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:  
    
       ```bash  
       vagrant@netology1:~$ ssh localhost 'tty'  
       not a tty  

   Почитайте, почему так происходит, и как изменить поведение.  
     

   Команды, указанные в строке ssh, запускаются неинтерактивно, и pty не выделяется. Нужно указать ключ -t. 

   
13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.
    ***  
    
    В новых версиях linux система безопасности не позволяет трассировать неродственные процессы по умолчанию. Необходимо в файле /proc/sys/kernel/yama/ptrace_scope изменить 1 на 0.  
	Далее:
		Запустить процесс в фоне `&`, либо выйти из уже запущенной задачи `Ctrl+z` и продолжить ее выполнение `bg`  
		Найти его pid в списке заданий `jobs -l` и удалить оттуда `disown [pid]`  
		Запустить screen  
		Выполнить `reptyr -L [pid]` 
		Теперь нужная задача привязана к процессу screen. При необходимости можно будет переподключиться и открыть нужное нам окно screen.  
      

14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.
    ***  
    
   	Команда tee копирует STDIN в указанные файлы и в STDOUT.  
	В отличие от перенаправления оболочкой '>' , sudo tee уже будет обладать нужными правами для записи в /root  
